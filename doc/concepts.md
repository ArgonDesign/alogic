<p align="center">
Previous |
<a href="index.md">Index</a> |
<a href="compilation.md">Next</a>
</p>

# Basic concepts and examples 

### Building blocks

The Alogic language uses a few key concepts for the description of digital
circuits. We aim to give a quick and incomplete overview here to pique the
interest of the adopter.

### Design entities

Each Alogic source file contains one fundamental design unit, called a [design
entity](entities.md). These are analogous to Verilog `modules` in that they can
be instantiated inside other entities to build a design hierarchy.

For example, one type of design entity is a [Finite State Machine](fsms.md),
which is described using code with locally sequential semantics similar to
common software programming languages. It can use function calls, conditionals
and other common control structures. The states of the FSM are generated by the
compiler and are not referred to explicitly in the Alogic code. Instead, the
Alogic Code is written as a sequential set of Control Blocks, and the compiler
computes the new state at the end of each Control Block. The Alogic code (within
one function) will be executed linearly from top to bottom. The state changes
happen on the positive clock edge. For example:

```
fsm foo {
  void main() {
  
    // At this point we are in state 0
    u8 a = ...; // a is an unsigned 8-bit value
    u8 b = a + 7; // b is an unsigned 8-bit value
    
    // 'if' statements can occur within a Control Block:
    if (a[0] == 1'b0) {
        a[0] = 1'b1;
    }
    // We are still in state 0
    
    fence; // This ends a Control Block - the state will change.
    
    // We are now in state 1. Code continues to be executed linearly.
    b += 8'd1;
    
    if (b[2:0] == 3'b0) {
      doit(); // This function call ends the Control Block
    } // An implicit else here also ends the Control Block
    // We are now in state 2 or 3 depending on the outcome.
  }

  void doit() {
    ...
  }
}
```

The main function must finish with a control statement so that the state can
return to 0.

### Ports

Communication between entities happens through well defined interfaces called
[ports](ports.md). A port carries some (usually registered) payload signals,
and optionally some flow control signals with well-defined semantics.

A simple example of a module that, on every clock cycle, reads an 8 bit value
from an input port using a valid-ready handshake and adds a quasi-static value
to it is as follows:

```
fsm add {
  in sync ready u8 p_in; // Input port, registered, with a valid-ready handshake.
  in u8 addend; // No flow control

  out sync ready u8 p_out; // Output port, registered, with a valid-ready handshake.

  void main() {
    u8 sum = p_in.read() + addend;
    p_out.write(sum);
    fence;
  }
}
```

Entities and their ports can then be connected using a different design entity
called a Network. See [design entity](entities.md) for more information.

<p align="center">
Previous |
<a href="index.md">Index</a> |
<a href="compilation.md">Next</a>
</p>
