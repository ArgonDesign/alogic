# Compilation model

### Alogic source files

All Alogic source files use the `.alogic` file extension. Every source file
contains an optional list of type definitions, followed by the definition of a
single [design entity](entities.md) in curly braces:

```
<optional type definitions>

<entity keyword> <entity name> {
  <entity description>
}
```

### The built-in preprocessor

When the compiler reads a source file, first it applies the built-in
preprocessor to the source text. This is a purely text based transformation.
The preprocessor uses the syntax of the standard C preprocessor,
though with a significantly reduced feature set. The main intention is to allow
sharing of type definitions using include files and to enable minimal
conditional compilation for debugging, and compile time parametrization through
macros. See the [preprocessor](preproc.md) page for the supported preprocessor
directives.

### Compilation process

The compilation of a complete Alogic design into it's Verilog representation is
done in one step, with a single invocation of the Alogic compiler, using roughly
the following steps:
 1. Read in all `.alogic` source files from a specified list of input paths
 1. Apply the built-in preprocessor to all input sources
 1. Translate all design entities into FSMs and Networks
 1. Resolve all instantiations and port connections
 1. Emit Verilog modules for each entity into the output directory

As an example, in order to compile all `.alogic` files under `src` into `.v`
files under `rtl`, one would invoke the Alogic compiler with the following
command line:

	alogic -o rtl src

See `alogic --help` for command line options.

### Downstream flow

After running the Alogic compiler to compile the Alogic language files into
their synthesized Verilog representation, the generated Verilog files can be
used for RTL simulation and implementation as any other Verilog source file.
The synthesized Verilog is independent of its corresponding Alogic source and
can be released as the canonical implementation without the Alogic sources.
There is no guarantee about the structure of the generated Verilog
implementation between compiler versions, and therefore we advise against
external modifications to generated source files. Verilog module interfaces
corresponding to file scope design entities should have stable module interfaces
across compiler versions.

### Clocking and Reset

Verilog implementations synthesized from Alogic language sources utilize a
single clock domain. Any logic generated by the compiler uses only rising edge
sensitive D flip-flops as sequential elements. The name of the clock signal in
the emitted Verilog is `clk`.

The only reset style currently supported by the compiler is active low
asynchronous reset. The name of the reset signal in the emitted Verilog is
`rst_n`.

Note that Alogic supports including arbitrary
[verbatim Verilog](interop.md#verbatim), in any design entity. These verbatim
contents are of course not required to follow the restrictions about clocking
and reset described above.

### Integration with other Verilog sources and testbenches

The aim of Alogic is not to replace Verilog as the sole design language. There
are cases where a direct Verilog description of a component is more appropriate,
and therefore interfacing modules synthesized from an Alogic language description
with other Verilog modules should be straight forward. Every Alogic port on a
design entity has a well defined translation into usually multiple ports on the
corresponding generated Verilog module. These translations and other Verilog
interoperability considerations are described in their own page on
[Verilog interoperability](interop.md)

### Debugging

During development, the designer runs RTL simulations of the generated Verilog.
Given the medium level of abstraction between Alogic and the corresponding
Verilog, mapping issues back from the Verilog source locations to the
corresponding Alogic source should be relatively simple in most cases.
Translations of various design entities are discussed in their own
documentation. Where there is ambiguity due to reusing variable names in
disjoint lexical scopes, the compiler tries to emit sensibly differentiated
names, for example by appending the source line number to variable instances.
