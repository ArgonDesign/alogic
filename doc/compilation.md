<p align="center">
<a href="concepts.md">Previous</a> |
<a href="index.md">Index</a> |
<a href="entities.md">Next</a>
</p>

# Compilation model

### Alogic source files

All Alogic source files use the `.alogic` file extension. Every source file
contains an optional list of type definitions, followed by the definition of a
single [design entity](entities.md) in curly braces:

```
<optional type definitions>

<entity keyword> <entity name> {
  <entity description>
}
```

If the entity name is foo, the source file must be named foo.alogic. The
compiler relies on this to find entity definitions and will produce an error if
there is a mismatch.

### Compilation Stages

Compilation of a complete Alogic design (one or more entities) into its Verilog
representation is done in one step, with a single invocation of the Alogic
compiler. Internally, there are 2 stages (although no intermediate files are
created), as follows:

![Compilation Stages](compilation.svg)

### Invoking the Compiler

To compile a complete Alogic design (one or more entities), the top-level
entities must be compiled together with any instantiated entities. The compiler
is typically invoked with a list of top level entity names, together with a list
of search directories specified with the `-y` option. At this point the compiler
will read in and parse all source files required for the design, based on the
entities instantiated by the design hierarchy below the specified top level
entities. The design then undergoes a successive list of transformations, at the
end of which a set of output files are written into the output directory
specified with the `-o` option.

For example, in order to compile a design with a top level entity called
`foo`, invoke the compiler using:

`alogic -o rtl -y src foo`

* The compiler seeks to compile the top-level entity `foo`
* -y src: the compiler searches for source files in the directory `src`
* -o rtl: the output is placed in the directory `rtl`

See `alogic --help` for more command line options.

### Downstream flow

After running the Alogic compiler to compile the Alogic language files into
their synthesized Verilog representation, the generated Verilog files can be
used for RTL simulation and implementation as any other Verilog source file. The
synthesized Verilog is independent of its corresponding Alogic source and can be
released as the canonical implementation without the Alogic sources. There is no
guarantee about the structure of the generated Verilog implementation between
compiler versions, and therefore we advise against external modifications to
generated source files. Verilog module interfaces corresponding to file scope
design entities should have stable module interfaces across compiler versions.

### Clocking and Reset

Verilog implementations synthesized from Alogic language sources utilize a
single clock domain. Any logic generated by the compiler uses only rising edge
sensitive D flip-flops as sequential elements. The name of the clock signal in
the emitted Verilog is `clk`.

The default reset style is active low asynchronous reset. However, a compiler
option permits the use of synchronous and/or active high reset. The name of the
reset signal in the emitted Verilog is `rst_n` (resp. `rst`) for active low (
resp. high) reset.

Note that Alogic supports including arbitrary target language source text in any
design entity using [verbatim blocks](interop.md#verbatim-blocks). These
verbatim contents are of course not required to follow the restrictions about
clocking and reset described above.

### Integration with other Verilog sources and testbenches

The aim of Alogic is not to replace Verilog as the sole design language. There
are cases where a direct Verilog description of a component is more appropriate,
and therefore interfacing modules synthesized from an Alogic language
description with other Verilog modules should be straight forward. Every Alogic
port on a design entity has a well defined translation into usually multiple
interface signals on the corresponding generated Verilog module. These
translations and other Verilog interoperability considerations are described in
their own page on [Verilog interoperability](interop.md)

### Debugging

During development, the designer runs RTL simulations of the generated Verilog.
Given the medium level of abstraction between Alogic and the corresponding
Verilog, mapping issues back from the Verilog source locations to the
corresponding Alogic source should be relatively simple in most cases. Where
there is ambiguity due to reusing variable names in disjoint lexical scopes, the
compiler tries to emit sensibly differentiated names, for example by appending
the source line number to variable instances.

<p align="center">
<a href="concepts.md">Previous</a> |
<a href="index.md">Index</a> |
<a href="entities.md">Next</a>
</p>
